<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modern Water Sectors Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .glass-card {
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .status-bar {
      height: 8px;
      transition: all 0.3s ease;
      border-radius: 4px;
    }
    
    .gradient-bg {
        background: linear-gradient(135deg, #9dd1e2 0%, #90EE90 100%);
    }
    
    .card-hover {
      transition: all 0.3s ease;
    }
    
    .card-hover:hover {
      transform: translateY(-5px);
    }
    
    .icon-container svg {
      transition: all 0.3s ease;
    }
    
    .icon-container:hover svg {
      transform: scale(1.1);
      color: #667eea;
    }
    
    .date-nav-button {
      transition: all 0.2s ease;
    }
    
    .date-nav-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
  </style>
</head>
<body class="min-h-screen gradient-bg p-4">
  <!-- Utilizamos un contenedor de ancho completo -->
  <div class="w-full">
    <h1 class="text-4xl font-bold text-white mb-12 text-center">
      Water Sectors Monitor
    </h1>
    
    <!-- Contenedor Grid responsivo para los sectores -->
    <div id="sectors-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
      <!-- Las tarjetas se insertarán aquí mediante JavaScript -->
    </div>
  </div>

  <!-- Plantilla para la tarjeta de sector -->
  <template id="sector-template">
    <div class="glass-card card-hover rounded-2xl shadow-xl overflow-hidden">
      <div class="p-6">
        <!-- Cabecera -->
        <div class="flex flex-col items-center mb-8">
          <h2 class="text-2xl text-center font-bold text-gray-800 sector-id mb-4"></h2>
          <div class="flex items-center justify-center space-x-2">
            <button class="date-nav-button text-gray-600 p-2 rounded-full" onclick="changeDate(this, -1)">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
              </svg>
            </button>
            <p class="text-lg text-gray-600 sector-date font-medium"></p>
            <button class="date-nav-button text-gray-600 p-2 rounded-full" onclick="changeDate(this, 1)">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </button>
          </div>
        </div>

        <!-- Cuadrícula de estadísticas -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
          <div class="bg-white/50 rounded-lg p-3">
            <p class="text-xs text-gray-600">Vol. Sector</p>
            <p class="text-lg font-bold text-gray-800 vol-sector"></p>
          </div>
          <div class="bg-white/50 rounded-lg p-3">
            <p class="text-xs text-gray-600">Vol. Abo.</p>
            <p class="text-lg font-bold text-gray-800 vol-abonados"></p>
          </div>
          <div class="bg-white/50 rounded-lg p-3">
            <p class="text-xs text-gray-600">ANR</p>
            <p class="text-lg font-bold text-gray-800 anr"></p>
          </div>
          <div class="bg-white/50 rounded-lg p-3">
            <p class="text-xs text-gray-600">Eficiencia</p>
            <p class="text-lg font-bold text-gray-800 percentage"></p>
          </div>
        </div>

        <!-- Barras de estado -->
        <div class="space-y-4">
          <div class="space-y-2">
            <div class="flex justify-between items-center">
              <span class="text-sm text-gray-600">Comunicaciones</span>
              <span class="text-sm font-semibold comunicaciones-value"></span>
            </div>
            <div class="bg-gray-200 rounded-full">
              <div class="status-bar bg-green-500" data-type="comunicaciones"></div>
            </div>
          </div>
          
          <div class="space-y-2">
            <div class="flex justify-between items-center">
              <span class="text-sm text-gray-600">Fiabilidad</span>
              <span class="text-sm font-semibold fiabilidad-value"></span>
            </div>
            <div class="bg-gray-200 rounded-full">
              <div class="status-bar bg-blue-500" data-type="fiabilidad"></div>
            </div>
          </div>
          
          <div class="space-y-2">
            <div class="flex justify-between items-center">
              <span class="text-sm text-gray-600">Coherencia</span>
              <span class="text-sm font-semibold coherencia-value"></span>
            </div>
            <div class="bg-gray-200 rounded-full">
              <div class="status-bar bg-purple-500" data-type="coherencia"></div>
            </div>
          </div>
        </div>

        <!-- Incidencias -->
        <div class="mt-6 flex items-center justify-between bg-red-50 rounded-lg p-4">
          <span class="text-sm text-red-700">Alarmas/Incidencias</span>
          <span class="incidents px-3 py-1 bg-red-200 text-red-800 rounded-full text-sm font-semibold"></span>
        </div>

        <!-- Íconos -->
        <div class="flex justify-center gap-8 mt-6 icon-container">
          <svg class="w-6 h-6 text-gray-600 cursor-pointer" viewBox="0 0 24 24">
            <path fill="currentColor" d="M3,3H21V21H3V3M7,7V17H10V7H7M11,7V17H14V7H11M15,7V17H18V7H15Z"/>
          </svg>
          <svg class="w-6 h-6 text-gray-600 cursor-pointer" viewBox="0 0 24 24">
            <path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"/>
          </svg>
        </div>
      </div>
    </div>
  </template>

  <script>
    const sectors = [
      {
        id: '3004_01_01_03',
        name: 'Vidales',
        "date": new Date(new Date().setDate(new Date().getDate() - 1)),
        // Estos valores se actualizarán con los cálculos de los históricos
        volSector: '-1 m³',
        volAbonados: '-1 m³',
        anr: '-1 m³',
        percentage: '0%',
        stats: {
          comunicaciones: 90,
          fiabilidad: 95.44,
          coherencia: 86.52
        },
        incidents: 0,
        tag: "GES300400011N00004",
        señalesSubsector: [
            "3004_CONT_P24UA624595N_CONTADOR",
            "3004_CONT_P24UA624601U_CONTADOR",
            "3004_CONT_P24IA615026S_CONTADOR",
            "3004_CONT_P24UA624732E_CONTADOR",
            "GES300400227N00001",
            "GES300400161N00001"
          ]
      },
      // {
      //   id: '3004_01_01_03',
      //   name: 'TORRE',
      //   date: new Date(new Date().setDate(new Date().getDate() - 1)),
      //   // Estos valores se actualizarán con los cálculos de los históricos
      //   volSector: '-1 m³',
      //   volAbonados: '-1 m³',
      //   anr: '-1 m³',
      //   percentage: '0%',
      //   stats: {
      //     comunicaciones: 90,
      //     fiabilidad: 95.44,
      //     coherencia: 86.52
      //   },
      //   incidents: 0,
      //   tag: "GES300400227N00001",
      //   señalesSubsector: [
      //       "3004_CONT_P24IA615002K_CONTADOR",
      //       "3004_CONT_P24IA614973W_CONTADOR",
      //       "3004_CONT_P24UA624602V_CONTADOR",
      //       "3004_CONT_P24UA624599R_CONTADOR",
      //       "3004_CONT_P24IA614968Z_CONTADOR",
      //       "3004_CONT_P24UA624738K_CONTADOR",
      //       "3004_CONT_P24UA624735H_CONTADOR"
      //     ]
      // },
      
      // Puedes agregar más sectores según necesites...
    ];

    function formatDate(date) {
      return date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' });
    }

    function createSectorCard(sector) {
      const template = document.getElementById('sector-template');
      const card = template.content.cloneNode(true);
      
      card.querySelector('.sector-id').textContent = `${sector.id} ${sector.name} (${sector.tag})`;
      card.querySelector('.sector-date').textContent = formatDate(sector.date);
      card.querySelector('.vol-sector').textContent = sector.volSector;
      card.querySelector('.vol-abonados').textContent = sector.volAbonados;
      card.querySelector('.anr').textContent = sector.anr;
      card.querySelector('.percentage').textContent = sector.percentage;
      
      // Configura las barras de estado y sus valores
      card.querySelector('[data-type="comunicaciones"]').style.width = `${sector.stats.comunicaciones}%`;
      card.querySelector('[data-type="fiabilidad"]').style.width = `${sector.stats.fiabilidad}%`;
      card.querySelector('[data-type="coherencia"]').style.width = `${sector.stats.coherencia}%`;
      
      card.querySelector('.comunicaciones-value').textContent = `${sector.stats.comunicaciones}%`;
      card.querySelector('.fiabilidad-value').textContent = `${sector.stats.fiabilidad}%`;
      card.querySelector('.coherencia-value').textContent = `${sector.stats.coherencia}%`;
      
      card.querySelector('.incidents').textContent = sector.incidents;
      
      return card;
    }

    function initializeDashboard() {
      const container = document.getElementById('sectors-container');
      sectors.forEach(sector => {
        container.appendChild(createSectorCard(sector));
      });
    }

      
    // Función que actualiza la fecha mostrada en la tarjeta y recarga sus datos históricos
    function changeDate(button, direction) {
      // Obtenemos la tarjeta (card) de la que se pulsó el botón.
      const card = button.closest('.glass-card');

      // Actualizamos la fecha mostrada en esa tarjeta.
      const dateElement = card.querySelector('.sector-date');
      const parts = dateElement.textContent.split('/');
      const currentDate = new Date(parts[2], parts[1] - 1, parts[0]);
      currentDate.setDate(currentDate.getDate() + direction);
      dateElement.textContent = formatDate(currentDate);

      // Extraemos el tag del sector desde el contenido de .sector-id.
      // Se asume que el tag está entre paréntesis, por ejemplo:
      // "3004_01_01_03 Los Gallos (GES300400011N00004)"
      const sectorIdText = card.querySelector('.sector-id').textContent;
      const tagMatch = sectorIdText.match(/\(([^)]+)\)/);
      if (!tagMatch) {
        console.warn("No se encontró el tag del sector en el texto:", sectorIdText);
        return;
      }
      const sectorTag = tagMatch[1];

      // Buscamos el sector en la lista global 'sectors'
      const sector = sectors.find(s => s.tag.trim() === sectorTag.trim());
      if (sector) {
        // Obtenemos un token y recargamos los datos históricos para la nueva fecha,
        // pasando también la referencia a la tarjeta (card) para actualizarla de forma individual.
        obtenerToken().then(token => {
          loadHistoricDataForSector(sector, currentDate, token, card);
        });
      } else {
        console.warn("No se encontró el sector para el tag:", sectorTag);
      }
    }

/**
 * Calcula el porcentaje de comunicaciones para las señales del subsector,
 * usando como fecha de análisis la fecha proporcionada menos un día.
 * 
 * @param {Array} historics - Array de objetos históricos devueltos por el servicio.
 * @param {Array} signalsSubsector - Array con los tags de las señales del subsector.
 * @param {Date} selectedDate - Objeto Date que representa la fecha seleccionada en la tarjeta.
 * @returns {number} Porcentaje de señales que han comunicado.
 */
  function calculateComunicacionesPercentage(historics, signalsSubsector, selectedDate) {
  // La fecha de análisis es un día antes de la fecha seleccionada
  const analysisDate = new Date(selectedDate);
  analysisDate.setDate(analysisDate.getDate());
  analysisDate.setHours(0, 0, 0, 0);

  const analysisDateEnd = new Date(analysisDate);
  analysisDateEnd.setHours(23, 59, 59, 999);

  let communicatedCount = 0;

  // Para cada señal del subsector, verificamos si existe al menos un dato dentro del rango del día de análisis
  signalsSubsector.forEach(signalTag => {
    // Buscamos en los históricos una entrada que corresponda a esta señal
    const hasData = historics.some(entry => {
      // Comprobar que el tag coincide
      if (entry.data.tag.trim() !== signalTag.trim()) return false;

      // Si no hay datos, se descarta
      if (!entry.data.data.ms || entry.data.data.ms.length === 0) return false;

      // Usamos el primer timestamp para determinar la fecha del registro (se puede ajustar si es necesario)
      const entryDate = new Date(entry.data.data.ms[0]);
      return (entryDate >= analysisDate && entryDate <= analysisDateEnd);
    });

    if (hasData) {
      communicatedCount++;
    }
  });

  return signalsSubsector.length > 0 ? (communicatedCount / signalsSubsector.length) * 100 : 0;
}

    /**
 * Solicita los históricos para el sector usando dos rangos (día actual y día anterior) y actualiza
 * los valores de la tarjeta.
 * 
 * @param {Object} sector Objeto con la información del sector.
 * @param {Date} referenceDate Fecha de referencia para obtener los históricos.
 * @param {String} token Token de autorización.
 * @param {HTMLElement} [cardElement] (Opcional) Elemento de la tarjeta a actualizar.
 */
 function loadHistoricDataForSector(sector, referenceDate, token, cardElement) {
  // 1. Calcular la fecha "máxima" (día actual) y el día anterior,
  //    ambos fijados a la medianoche (00:00)
  let currentDay = new Date(referenceDate);
  currentDay.setHours(0, 0, 0, 0);
  let previousDay = new Date(referenceDate);
  previousDay.setDate(previousDay.getDate() - 1);
  previousDay.setHours(0, 0, 0, 0);

  // Definimos un único rango que va desde el día anterior a las 00:00 hasta el día actual a las 00:00.
  const startISO = previousDay.toISOString();
  const endISO = currentDay.toISOString();

  // 2. Generamos la petición para cada etiqueta (una por cada señal del subsector y una para la etiqueta del sector).
  //    Para la etiqueta del sector agregamos el parámetro 'sn'
  const requests = [];

  // Para cada señal del subsector:
  sector.señalesSubsector.forEach(signalTag => {
    requests.push({
      startDate: startISO,
      endDate: endISO,
      tzi: "Europe/Madrid",
      interval: 0,
      top: 672,//una semana a datos de 15 min
      skip: 0,
      prev: false,
      next: false,
      dataVersion: "RAW",
      asc: false,
      tag: signalTag.trim()
    });
  });

  // Para la etiqueta del sector (agregamos el parámetro 'sn' para que se incluya en la respuesta)
  requests.push({
    startDate: startISO,
    endDate: endISO,
    tzi: "Europe/Madrid",
    interval: 0,
    top: 672,
    skip: 0,
    prev: false,
    next: false,
    dataVersion: "RAW",
    asc: false,
    tag: sector.tag.trim()
  });

  // 3. Realizar la llamada al servicio con todas las peticiones en una sola llamada.
  fetch("https://hermesmanager.saur.com.es/api/Historic/listHistoric", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + token
    },
    body: JSON.stringify(requests)
  })
    .then(response => response.json())
    .then(data => {
      console.log("Datos históricos para el sector", sector.tag, data);
      
      // Variables para guardar los valores obtenidos para el sector y las señales abonadas.
      let currentSectorValue = null;
      let previousSectorValue = null;
      let currentAbonadoSum = 0;
      let previousAbonadoSum = 0;

      // Función auxiliar para obtener, de un historicEntry, el valor cuya lectura esté más
      // cerca de la medianoche del día indicado (targetDate).
      function getNearestValue(historicEntry, targetDate) {
        if (
          !historicEntry.data.data ||
          !historicEntry.data.data.ms ||
          historicEntry.data.data.ms.length === 0
        )
          return null;
        const target = new Date(targetDate);
        target.setHours(0, 0, 0, 0);
        let nearest = null;
        let minDiff = Infinity;
        historicEntry.data.data.ms.forEach((msValue, index) => {
          const readingDate = new Date(msValue);
          const diff = Math.abs(readingDate - target);
          if (diff < minDiff) {
            minDiff = diff;
            nearest = historicEntry.data.data.vs["0"][index];
          }
        });
        return nearest;
      }

      // 4. Procesar cada entrada devuelta. Cada objeto de la respuesta corresponde a una petición.
      //    Se obtiene el valor para el día anterior (target = previousDay) y para el día actual (target = currentDay)
      data.historics.forEach(entry => {
        const tag = entry.data.tag;
        // Obtenemos el valor más cercano a la medianoche para ambos días:
        const valuePrevious = getNearestValue(entry, previousDay);
        const valueCurrent = getNearestValue(entry, currentDay);
        if (valuePrevious === null || valueCurrent === null) return; // Si falta alguno, lo omitimos

        if (tag === sector.tag.trim()) {
          // Para la etiqueta del sector
          previousSectorValue = valuePrevious;
          currentSectorValue = valueCurrent;
        } else if (sector.señalesSubsector.includes(tag)) {
          // Para cada señal del subsector se acumulan sus valores
          previousAbonadoSum += valuePrevious;
          currentAbonadoSum += valueCurrent;
        }
      });

      // Si usas una función para calcular el porcentaje de comunicaciones, se puede invocar aquí.
      const communicationsPercent = calculateComunicacionesPercentage(
        data.historics,
        sector.señalesSubsector,
        referenceDate
      );

      // 5. Realizar los cálculos si se tienen los valores necesarios.
      if (currentSectorValue != null && previousSectorValue != null) {
        const volSectorCalc = currentSectorValue - previousSectorValue;
        const volAbonadosCalc = currentAbonadoSum - previousAbonadoSum;
        const anrCalc = volSectorCalc - volAbonadosCalc;
        const efficiencyCalc =
          volSectorCalc !== 0 ? (volAbonadosCalc / volSectorCalc) * 100 : 0;

        // Actualizar la tarjeta (ya sea la pasada como parámetro o todas las que correspondan)
        if (cardElement) {
          cardElement.querySelector('.vol-sector').textContent =
            volSectorCalc.toFixed(2) + " m³";
          cardElement.querySelector('.vol-abonados').textContent =
            volAbonadosCalc.toFixed(2) + " m³";
          cardElement.querySelector('.anr').textContent =
            anrCalc.toFixed(2) + " m³";
          cardElement.querySelector('.percentage').textContent =
            efficiencyCalc.toFixed(2) + " %";
          cardElement.querySelector('.comunicaciones-value').textContent =
            communicationsPercent.toFixed(2) + " %";
          cardElement.querySelector('[data-type="comunicaciones"]').style.width =
            communicationsPercent.toFixed(2) + "%";
        } else {
          const cards = document.querySelectorAll('.glass-card');
          cards.forEach(card => {
            if (card.querySelector('.sector-id').textContent.indexOf(sector.tag) !== -1) {
              card.querySelector('.vol-sector').textContent =
                volSectorCalc.toFixed(2) + " m³";
              card.querySelector('.vol-abonados').textContent =
                volAbonadosCalc.toFixed(2) + " m³";
              card.querySelector('.anr').textContent =
                anrCalc.toFixed(2) + " m³";
              card.querySelector('.percentage').textContent =
                efficiencyCalc.toFixed(2) + " %";
              card.querySelector('.comunicaciones-value').textContent =
                communicationsPercent.toFixed(2) + " %";
              card.querySelector('[data-type="comunicaciones"]').style.width =
                communicationsPercent.toFixed(2) + "%";
            }
          });
        }
      } else {
        console.warn("No se pudieron obtener los valores completos para el sector", sector.tag);
      }
    })
    .catch(error => {
      console.error("Error al obtener los históricos para el sector", sector.tag, error);
    });
}


  function obtenerToken() {
      const url = "https://authentication.gestagua.es/auth/realms/Gestagua/protocol/openid-connect/token"; // Reemplaza con la URL real para obtener el token
      const params = new URLSearchParams();
      params.append("grant_type", "password");
      params.append("client_id", "hermes-app");     // Reemplaza con el client_id configurado
      params.append("username", "cguerrero");        // Reemplaza con el usuario
      params.append("password", "123456");       // Reemplaza con la contraseña

      return fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: params
      })
      .then(response => {
        if (!response.ok) {
          throw new Error("Error en la petición de token");
        }
        return response.json();
      })
      .then(data => {
        console.log("Token obtenido:", data.access_token);
        return data.access_token; // Se asume que el token se encuentra en data.access_token
      })
      .catch(error => {
        console.error("Error al obtener el token:", error);
      });
    }

// Al cargar la página, se inicializa el dashboard y se solicitan los históricos para cada sector
document.addEventListener('DOMContentLoaded', () => {
        initializeDashboard();
        obtenerToken().then(token => {
            sectors.forEach(sector => {
                loadHistoricDataForSector(sector, sector.date, token);
            });
        });
    });

  
  </script>
</body>
</html>
